// Code generated by oapi-codegen. DO NOT EDIT.

package customclienttype

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/doordash/oapi-codegen/v3/pkg/runtime"
	"github.com/google/go-querystring/query"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// HttpRequestDoer performs HTTP requests.
type HttpRequestDoer interface {
	Do(context context.Context, req *http.Request) (*http.Response, error)
}

// CustomClientType is the client for the API implementing the CustomClientType interface.
// baseURL is the base URL for the API.
// httpClient is the HTTP client to use for making requests.
// logger is the logger to use for logging.
// requestEditors is a list of callbacks for modifying requests which are generated before sending over the network.
type CustomClientType struct {
	baseURL        string
	httpClient     HttpRequestDoer
	requestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction.
type CustomClientTypeOption func(*CustomClientType) error

// NewClient creates a new client, with reasonable defaults.
func NewClient(baseURL string, opts ...CustomClientTypeOption) (*CustomClientType, error) {
	// create a client with sane default values
	res := &CustomClientType{
		baseURL: strings.TrimSuffix(baseURL, "/"),
	}

	// mutate client and add all optional params
	for _, opt := range opts {
		if err := opt(res); err != nil {
			return nil, err
		}
	}

	return res, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client.
func WithHTTPClient(doer HttpRequestDoer) CustomClientTypeOption {
	return func(c *CustomClientType) error {
		c.httpClient = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) CustomClientTypeOption {
	return func(c *CustomClientType) error {
		c.requestEditors = append(c.requestEditors, fn)
		return nil
	}
}

// ClientInterface is the interface for the API client.
type CustomClientTypeInterface interface {
	GetClient(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientResponse, error)
}

func (c *CustomClientType) GetClient(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientResponse, error) {
	var err error
	url := c.baseURL + "/client"
	req, err := createRequest(ctx, url, "GET", nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, fmt.Errorf("error applying request editors: %w", err)
	}

	resp, err := c.httpClient.Do(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}

	var bodyBytes []byte
	if resp.Body != nil {
		defer resp.Body.Close()
		bodyBytes, err = io.ReadAll(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}
	}

	if resp.StatusCode != 200 {
		return nil, runtime.NewClientAPIError(fmt.Errorf("unexpected status code: %d", resp.StatusCode))
	}
	target := new(GetClientResponse)
	if err = json.Unmarshal(bodyBytes, target); err != nil {
		err = fmt.Errorf("error decoding response: %w", err)
		return nil, err
	}
	return target, nil
}

// applyEditors applies all the request editors to the request.
func (c *CustomClientType) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.requestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

type RequestOptions interface {
	GetPathParams() (map[string]any, error)
	GetQuery() (map[string]any, error)
	GetBody() any
	GetHeader() (map[string]string, error)
}

// createRequest creates a new POST request with the given URL, payload and headers.
func createRequest(ctx context.Context, url, method string, options RequestOptions) (*http.Request, error) {
	pathParams, err := options.GetPathParams()
	if err != nil {
		return nil, err
	}
	url = strings.TrimSuffix(url, "/")
	url = replacePathPlaceholders(url, pathParams)

	queryParams, err := options.GetQuery()
	if err != nil {
		return nil, err
	}
	if len(queryParams) > 0 {
		var pairs []string
		for k, v := range queryParams {
			pairs = append(pairs, fmt.Sprintf("%s=%v", k, v))
		}
		url = fmt.Sprintf("%s?%s", url, strings.Join(pairs, "&"))
	}

	payload := options.GetBody()

	headers, err := options.GetHeader()
	if err != nil {
		return nil, err
	}
	if headers == nil {
		headers = map[string]string{
			"Content-Type": "application/json",
		}
	}
	httpHeaders := http.Header{}
	for k, v := range headers {
		httpHeaders.Set(k, v)
	}

	var bodyReader io.Reader
	var encodedPayload string

	// Check if request should be form-encoded
	if strings.HasPrefix(headers["Content-Type"], "application/x-www-form-urlencoded") {
		formValues, err := query.Values(payload)
		if err != nil {
			return nil, fmt.Errorf("error encoding form values: %w", err)
		}
		encodedPayload = formValues.Encode()
		bodyReader = strings.NewReader(encodedPayload)
	} else {
		// Default to JSON encoding
		body, err := json.Marshal(payload)
		if err != nil {
			return nil, err
		}
		encodedPayload = string(body)
		bodyReader = bytes.NewBuffer(body)
	}

	req, err := http.NewRequestWithContext(ctx, method, url, bodyReader)
	if err != nil {
		return nil, err
	}

	req.Header = httpHeaders

	return req, nil
}

func replacePathPlaceholders(url string, pathParams map[string]any) string {
	for k, v := range pathParams {
		url = strings.Replace(url, fmt.Sprintf("{%s}", k), fmt.Sprintf("%v", v), -1)
	}
	return url
}

var _ CustomClientTypeInterface = (*CustomClientType)(nil)
