// Copyright 2025 DoorDash, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

package codegen

import (
	"fmt"
	"slices"
	"strconv"
	"strings"

	"github.com/pb33f/libopenapi/datamodel/high/base"
)

// EnumDefinition holds type information for enum
// Schema is the scheme of a type which has a list of enum values, eg, the
// "container" of the enum.
// Name is the name of the enum's type, usually aliased from something.
// EnumDefinition represents an enum type.
// ValueWrapper wraps the value. It's used to conditionally apply quotes around strings.
// PrefixTypeName determines if the enum value is prefixed with its TypeName.
// Values contains the final constant names mapped to their values (computed in filterOutEnums).
// SpecLocation indicates where in the OpenAPI spec this enum was defined.
type EnumDefinition struct {
	Name           string
	ValueWrapper   string
	PrefixTypeName bool
	Schema         GoSchema
	Values         []EnumValue
	SpecLocation   SpecLocation
}

// EnumValue represents a single enum constant.
type EnumValue struct {
	Name  string
	Value string
}

func createEnumsSchema(schema *base.Schema, options ParseOptions) (GoSchema, error) {
	outSchema, err := oapiSchemaToGoType(schema, options)
	if err != nil {
		return GoSchema{}, fmt.Errorf("error resolving primitive type: %w", err)
	}

	path := options.path

	// Enums need to be typed, so that the values aren't interchangeable,
	// so no matter what schema conversion thinks, we need to define a
	// new type.
	outSchema.DefineViaAlias = false

	enumValues := make([]string, len(schema.Enum))
	for i, enumNode := range schema.Enum {
		enumValues[i] = enumNode.Value
	}

	enumNames := enumValues
	exts := extractExtensions(schema.Extensions)
	for _, key := range []string{extEnumNames} {
		if extension, ok := exts[key]; ok {
			names, err := extParseEnumVarNames(extension)
			if err != nil {
				return outSchema, fmt.Errorf("invalid value for %q: %w", key, err)
			}
			enumNames = names
		}
	}

	sanitizedValues := sanitizeEnumNames(enumNames, enumValues)

	// If all enum values were filtered out (e.g., all were null),
	// treat this as a regular type, not an enum
	if len(sanitizedValues) == 0 {
		// Return a regular type without enum values
		return oapiSchemaToGoType(schema, options)
	}

	outSchema.EnumValues = make(map[string]string, len(sanitizedValues))

	for k, v := range sanitizedValues {
		outSchema.EnumValues[schemaNameToTypeName(k)] = v
	}

	// Fix GoType if enum values don't match the declared type
	// This handles specs that declare type: integer but have string enum values
	if len(sanitizedValues) > 0 {
		// Check the first enum value to determine the actual type
		for _, value := range sanitizedValues {
			if needsQuotesForEnumValue(value, outSchema.GoType) {
				// The enum values are strings but the declared type is not string
				// Override the GoType to string to match the actual values
				outSchema.GoType = "string"
			}
			// Only need to check one value
			break
		}
	}

	if len(path) == 0 {
		return outSchema, nil
	}

	if len(path) > 1 {
		// handle additional type only on non-toplevel types
		// Allow overriding autogenerated enum type names, since these may
		// cause conflicts - see https://github.com/oapi-codegen/oapi-codegen/issues/832
		var typeName string
		if extension, ok := exts[extGoTypeName]; ok {
			typeName, err = parseString(extension)
			if err != nil {
				return outSchema, fmt.Errorf("invalid value for %q: %w", extGoTypeName, err)
			}
		} else {
			typeName = schemaNameToTypeName(pathToTypeName(path))
		}

		// Check if a type with the same name already exists.
		// If it does, generate a unique name to avoid conflicts.
		if options.typeTracker.Exists(typeName) {
			typeName = options.typeTracker.generateUniqueName(typeName)
		}

		typeDef := TypeDefinition{
			Name:         typeName,
			JsonName:     strings.Join(path, "."),
			Schema:       outSchema,
			SpecLocation: options.specLocation,
		}
		outSchema.AdditionalTypes = append(outSchema.AdditionalTypes, typeDef)
		outSchema.RefType = typeName
		options.typeTracker.register(typeDef, "")
	}

	return outSchema, nil
}

// sanitizeEnumNames fixes illegal chars in the enum names
// and removes duplicates
func sanitizeEnumNames(enumNames, enumValues []string) map[string]string {
	dupCheck := make(map[string]int, len(enumValues))
	deDup := make([][]string, 0, len(enumValues))

	for i, v := range enumValues {
		// Skip null values - they cannot be represented as Go constants
		// null in JSON/OpenAPI should be represented as nil in Go (for pointers)
		// Note: empty string "" is valid and should NOT be filtered out
		if v == "null" {
			continue
		}

		n := v
		if i < len(enumNames) {
			n = enumNames[i]
		}
		if _, dup := dupCheck[n]; !dup {
			deDup = append(deDup, []string{n, v})
		}
		dupCheck[n] = 0
	}

	dupCheck = make(map[string]int, len(deDup))
	sanitizedDeDup := make(map[string]string, len(deDup))

	for _, p := range deDup {
		n, v := p[0], p[1]
		sanitized := sanitizeGoIdentity(schemaNameToTypeName(n))

		// If sanitized is empty (all chars were special chars that got stripped),
		// use "Empty" as the base name. The duplicate handling below will add
		// numeric suffixes if there are multiple such values.
		if sanitized == "" {
			sanitized = "Value"
		}

		if _, dup := dupCheck[sanitized]; !dup {
			sanitizedDeDup[sanitized] = v
		} else {
			sanitizedDeDup[sanitized+strconv.Itoa(dupCheck[sanitized])] = v
		}
		dupCheck[sanitized]++
	}

	return sanitizedDeDup
}

func filterOutEnums(types []TypeDefinition, options ParseOptions) ([]EnumDefinition, []TypeDefinition) {
	var enums []EnumDefinition
	var rest []TypeDefinition

	// Keep track of which enums we've generated
	m := map[string]int{}

	// These are all types defined globally
	for _, td := range types {
		if cnt := m[td.Name]; cnt > 0 {
			continue
		}

		for _, p := range td.Schema.Properties {
			if len(p.Schema.EnumValues) == 0 {
				continue
			}

			// Skip enum generation for types that can't be used as constants or map keys
			// (arrays, slices, maps, structs, etc.)
			if !isComparableType(p.Schema) {
				continue
			}

			name := p.Schema.RefType
			if name == "" {
				name = p.GoName
			}

			if cnt := m[name]; cnt > 0 {
				continue
			}

			// Determine the wrapper based on the actual enum values
			// For arrays with enum items, check the array element type
			wrapper := ""
			enumType := p.Schema.GoType
			if p.Schema.ArrayType != nil {
				// For array types, the enum values are from the items, not the array itself
				enumType = p.Schema.ArrayType.GoType
			}

			// Check if any enum value needs quotes
			// This handles cases where the spec declares type: integer but has string enum values
			if len(p.Schema.EnumValues) > 0 {
				// Check the first enum value to determine if quotes are needed
				for _, value := range p.Schema.EnumValues {
					if needsQuotesForEnumValue(value, enumType) {
						wrapper = `"`
					}
					// Only need to check one value
					break
				}
			}

			enums = append(enums, EnumDefinition{
				Schema:         p.Schema,
				Name:           name,
				ValueWrapper:   wrapper,
				PrefixTypeName: options.AlwaysPrefixEnumValues,
				SpecLocation:   td.SpecLocation,
			})
			m[name] = 1
		}

		if len(td.Schema.EnumValues) > 0 {
			// Skip enum generation for types that can't be used as constants or map keys
			// (arrays, slices, maps, structs, etc.)
			if isComparableType(td.Schema) {
				wrapper := ""
				// Check if any enum value needs quotes
				// This handles cases where the spec declares type: integer but has string enum values
				for _, value := range td.Schema.EnumValues {
					if needsQuotesForEnumValue(value, td.Schema.GoType) {
						wrapper = `"`
					}
					// Only need to check one value
					break
				}
				enums = append(enums, EnumDefinition{
					Schema:         td.Schema,
					Name:           td.Name,
					ValueWrapper:   wrapper,
					PrefixTypeName: options.AlwaysPrefixEnumValues,
					SpecLocation:   td.SpecLocation,
				})
			} else {
				rest = append(rest, td)
			}
		} else {
			rest = append(rest, td)
		}
		m[td.Name] = 1
	}

	// Go through all enums, compute final Values and register in typeTracker.
	// Per-value conflict resolution handles all conflicts individually:
	// - Conflicts with type names
	// - Conflicts between enum values from different enums
	// - Self-conflicts (enum value same as enum type name)
	for i := range enums {
		e := enums[i]

		// Compute final Values.
		values := make([]EnumValue, 0, len(e.Schema.EnumValues))
		for k, v := range e.Schema.EnumValues {
			// Base name depends on prefix setting.
			baseName := k
			if e.PrefixTypeName {
				baseName = e.Name + UppercaseFirstCharacter(k)
			}

			// Conflict resolution order:
			// 1. Unprefixed name (e.g., "Debit")
			// 2. Type-prefixed name (e.g., "TypeDebit")
			// 3. SpecLocation-suffixed name (e.g., "DebitParameter")
			// 4. Numeric suffix on SpecLocation name (e.g., "DebitParameter1")
			var name string
			if !options.typeTracker.Exists(baseName) {
				// No conflict, use the base name as-is.
				name = baseName
			} else if !e.PrefixTypeName {
				// Conflict exists and we're not already using prefix.
				// Try prefixed name before other fallbacks.
				prefixedName := e.Name + UppercaseFirstCharacter(k)
				if !options.typeTracker.Exists(prefixedName) {
					name = prefixedName
				} else if e.SpecLocation != "" {
					// Try SpecLocation suffix (e.g., "DebitParameter")
					specSuffix := UppercaseFirstCharacter(string(e.SpecLocation))
					specName := k + specSuffix
					if !options.typeTracker.Exists(specName) {
						name = specName
					} else {
						// SpecLocation name also conflicts, use numeric suffix on it
						name = options.typeTracker.generateUniqueName(specName)
					}
				} else {
					// No SpecLocation, fall back to numeric suffix on base name
					name = options.typeTracker.generateUniqueName(baseName)
				}
			} else if e.SpecLocation != "" {
				// Already using prefix and it conflicts, try SpecLocation suffix
				specSuffix := UppercaseFirstCharacter(string(e.SpecLocation))
				specName := baseName + specSuffix
				if !options.typeTracker.Exists(specName) {
					name = specName
				} else {
					// SpecLocation name also conflicts, use numeric suffix on it
					name = options.typeTracker.generateUniqueName(specName)
				}
			} else {
				// No SpecLocation, fall back to numeric suffix
				name = options.typeTracker.generateUniqueName(baseName)
			}

			options.typeTracker.registerName(name)
			values = append(values, EnumValue{Name: name, Value: v})
		}
		slices.SortFunc(values, func(a, b EnumValue) int {
			return strings.Compare(a.Name, b.Name)
		})
		enums[i].Values = values
	}

	return enums, rest
}

// nonConstantTypes contains Go types that cannot be used as constants.
// These are typically struct types, arrays, or other non-primitive types
// that require runtime initialization.
var nonConstantTypes = map[string]bool{
	"time.Time":    true, // requires runtime initialization
	"runtime.File": true, // struct type for binary file uploads
	"uuid.UUID":    true, // [16]byte array type
}

// isComparableType checks if a Go type can be used as a constant or map key
func isComparableType(schema GoSchema) bool {
	// Arrays, slices, maps, and structs cannot be used as constants or map keys
	if schema.ArrayType != nil {
		return false
	}
	if schema.IsAnyType() {
		return false
	}
	if len(schema.Properties) > 0 {
		return false
	}

	// Check against known non-constant types
	if nonConstantTypes[schema.GoType] {
		return false
	}

	// Only primitive types (string, int, float, bool) can be used as enum constants
	return true
}

// needsQuotesForEnumValue determines if an enum value needs quotes based on the actual value
// rather than just the declared type. This handles cases where the spec declares type: integer
// but provides string enum values.
func needsQuotesForEnumValue(value string, goType string) bool {
	// If the declared type is string, always use quotes
	if goType == "string" {
		return true
	}

	// For integer types, check if the value is actually a valid integer
	if strings.HasPrefix(goType, "int") {
		// Try to parse as an integer - if it fails, it's a string and needs quotes
		_, err := strconv.ParseInt(value, 10, 64)
		return err != nil
	}

	// For float types, check if the value is actually numeric
	if strings.HasPrefix(goType, "float") || goType == "number" {
		// Try to parse as a number - if it fails, it's a string and needs quotes
		_, err := strconv.ParseFloat(value, 64)
		return err != nil
	}

	// For bool type, check if value is actually a boolean
	if goType == "bool" {
		_, err := strconv.ParseBool(value)
		return err != nil
	}

	// Default: no quotes for other types
	return false
}
