// Copyright 2025 DoorDash, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

package codegen

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/pb33f/libopenapi/datamodel/high/base"
)

// EnumDefinition holds type information for enum
// Schema is the scheme of a type which has a list of enum values, eg, the
// "container" of the enum.
// Name is the name of the enum's type, usually aliased from something.
// ValueWrapper wraps the value. It's used to conditionally apply quotes
// around strings.
// PrefixTypeName determines if the enum value is prefixed with its TypeName.
type EnumDefinition struct {
	Name           string
	ValueWrapper   string
	PrefixTypeName bool
	Schema         GoSchema
}

// GetValues generates enum names in a way to minimize global conflicts
func (e *EnumDefinition) GetValues() map[string]string {
	// in case there are no conflicts, it's safe to use the values as-is
	if !e.PrefixTypeName {
		return e.Schema.EnumValues
	}

	// If we do have conflicts, we will prefix the enum's typename to the values.
	newValues := make(map[string]string, len(e.Schema.EnumValues))
	for k, v := range e.Schema.EnumValues {
		newName := e.Name + UppercaseFirstCharacter(k)
		newValues[newName] = v
	}
	return newValues
}

func createEnumsSchema(schema *base.Schema, options ParseOptions) (GoSchema, error) {
	outSchema, err := oapiSchemaToGoType(schema, options)
	if err != nil {
		return GoSchema{}, fmt.Errorf("error resolving primitive type: %w", err)
	}

	path := options.path

	// Enums need to be typed, so that the values aren't interchangeable,
	// so no matter what schema conversion thinks, we need to define a
	// new type.
	outSchema.DefineViaAlias = false

	enumValues := make([]string, len(schema.Enum))
	for i, enumNode := range schema.Enum {
		enumValues[i] = enumNode.Value
	}

	enumNames := enumValues
	exts := extractExtensions(schema.Extensions)
	for _, key := range []string{extEnumNames} {
		if extension, ok := exts[key]; ok {
			names, err := extParseEnumVarNames(extension)
			if err != nil {
				return outSchema, fmt.Errorf("invalid value for %q: %w", key, err)
			}
			enumNames = names
		}
	}

	sanitizedValues := sanitizeEnumNames(enumNames, enumValues)

	// If all enum values were filtered out (e.g., all were null),
	// treat this as a regular type, not an enum
	if len(sanitizedValues) == 0 {
		// Return a regular type without enum values
		return oapiSchemaToGoType(schema, options)
	}

	outSchema.EnumValues = make(map[string]string, len(sanitizedValues))

	for k, v := range sanitizedValues {
		outSchema.EnumValues[schemaNameToTypeName(k)] = v
	}

	// Fix GoType if enum values don't match the declared type
	// This handles specs that declare type: integer but have string enum values
	if len(sanitizedValues) > 0 {
		// Check the first enum value to determine the actual type
		for _, value := range sanitizedValues {
			if needsQuotesForEnumValue(value, outSchema.GoType) {
				// The enum values are strings but the declared type is not string
				// Override the GoType to string to match the actual values
				outSchema.GoType = "string"
			}
			// Only need to check one value
			break
		}
	}

	if len(path) == 0 {
		return outSchema, nil
	}

	if len(path) > 1 {
		// handle additional type only on non-toplevel types
		// Allow overriding autogenerated enum type names, since these may
		// cause conflicts - see https://github.com/oapi-codegen/oapi-codegen/issues/832
		var typeName string
		if extension, ok := exts[extGoTypeName]; ok {
			typeName, err = parseString(extension)
			if err != nil {
				return outSchema, fmt.Errorf("invalid value for %q: %w", extGoTypeName, err)
			}
		} else {
			typeName = schemaNameToTypeName(pathToTypeName(path))
		}

		// Check if a type with the same name already exists.
		// If it does, generate a unique name to avoid conflicts.
		if _, exists := options.currentTypes[typeName]; exists {
			typeName = generateTypeName(options.currentTypes, typeName, options.nameSuffixes)
		}

		typeDef := TypeDefinition{
			Name:     typeName,
			JsonName: strings.Join(path, "."),
			Schema:   outSchema,
		}
		outSchema.AdditionalTypes = append(outSchema.AdditionalTypes, typeDef)
		outSchema.RefType = typeName
		options.AddType(typeDef)
	}

	return outSchema, nil
}

// sanitizeEnumNames fixes illegal chars in the enum names
// and removes duplicates
func sanitizeEnumNames(enumNames, enumValues []string) map[string]string {
	dupCheck := make(map[string]int, len(enumValues))
	deDup := make([][]string, 0, len(enumValues))

	for i, v := range enumValues {
		// Skip null values - they cannot be represented as Go constants
		// null in JSON/OpenAPI should be represented as nil in Go (for pointers)
		// Note: empty string "" is valid and should NOT be filtered out
		if v == "null" {
			continue
		}

		n := v
		if i < len(enumNames) {
			n = enumNames[i]
		}
		if _, dup := dupCheck[n]; !dup {
			deDup = append(deDup, []string{n, v})
		}
		dupCheck[n] = 0
	}

	dupCheck = make(map[string]int, len(deDup))
	sanitizedDeDup := make(map[string]string, len(deDup))

	for _, p := range deDup {
		n, v := p[0], p[1]
		sanitized := sanitizeGoIdentity(schemaNameToTypeName(n))

		if _, dup := dupCheck[sanitized]; !dup {
			sanitizedDeDup[sanitized] = v
		} else {
			sanitizedDeDup[sanitized+strconv.Itoa(dupCheck[sanitized])] = v
		}
		dupCheck[sanitized]++
	}

	return sanitizedDeDup
}

func filterOutEnums(types []TypeDefinition, options ParseOptions) ([]EnumDefinition, []TypeDefinition, TypeRegistry) {
	var enums []EnumDefinition
	var rest []TypeDefinition

	// Keep track of which enums we've generated
	m := map[string]int{}

	// These are all types defined globally
	for _, td := range types {
		if cnt := m[td.Name]; cnt > 0 {
			continue
		}

		for _, p := range td.Schema.Properties {
			if len(p.Schema.EnumValues) == 0 {
				continue
			}

			// Skip enum generation for types that can't be used as constants or map keys
			// (arrays, slices, maps, structs, etc.)
			if !isComparableType(p.Schema) {
				continue
			}

			name := p.Schema.RefType
			if name == "" {
				name = p.GoName
			}

			if cnt := m[name]; cnt > 0 {
				continue
			}

			// Determine the wrapper based on the actual enum values
			// For arrays with enum items, check the array element type
			wrapper := ""
			enumType := p.Schema.GoType
			if p.Schema.ArrayType != nil {
				// For array types, the enum values are from the items, not the array itself
				enumType = p.Schema.ArrayType.GoType
			}

			// Check if any enum value needs quotes
			// This handles cases where the spec declares type: integer but has string enum values
			if len(p.Schema.EnumValues) > 0 {
				// Check the first enum value to determine if quotes are needed
				for _, value := range p.Schema.EnumValues {
					if needsQuotesForEnumValue(value, enumType) {
						wrapper = `"`
					}
					// Only need to check one value
					break
				}
			}

			enums = append(enums, EnumDefinition{
				Schema:         p.Schema,
				Name:           name,
				ValueWrapper:   wrapper,
				PrefixTypeName: options.AlwaysPrefixEnumValues,
			})
			m[name] = 1
		}

		if len(td.Schema.EnumValues) > 0 {
			// Skip enum generation for types that can't be used as constants or map keys
			// (arrays, slices, maps, structs, etc.)
			if isComparableType(td.Schema) {
				wrapper := ""
				// Check if any enum value needs quotes
				// This handles cases where the spec declares type: integer but has string enum values
				for _, value := range td.Schema.EnumValues {
					if needsQuotesForEnumValue(value, td.Schema.GoType) {
						wrapper = `"`
					}
					// Only need to check one value
					break
				}
				enums = append(enums, EnumDefinition{
					Schema:         td.Schema,
					Name:           td.Name,
					ValueWrapper:   wrapper,
					PrefixTypeName: options.AlwaysPrefixEnumValues,
				})
			} else {
				rest = append(rest, td)
			}
		} else {
			rest = append(rest, td)
		}
		m[td.Name] = 1
	}

	// Now, go through all the enums, and figure out if we have conflicts with any others.
	for i := range enums {
		// Look through all other enums not compared so far.
		// Make sure we don't compare against self.
		e1 := enums[i]
		for j := i + 1; j < len(enums); j++ {
			e2 := enums[j]

			for e1key := range e1.GetValues() {
				_, found := e2.GetValues()[e1key]
				if found {
					e1.PrefixTypeName = true
					e2.PrefixTypeName = true
					enums[i] = e1
					enums[j] = e2
					break
				}
			}
		}

		// now see if this enum conflicts with any type names.
		for _, tp := range types {
			// Skip over enums, since we've handled those above.
			if len(tp.Schema.EnumValues) > 0 {
				continue
			}
			_, found := e1.Schema.EnumValues[tp.Name]
			if found {
				e1.PrefixTypeName = true
				enums[i] = e1
			}
		}

		_, found := e1.GetValues()[e1.Name]
		if found {
			e1.PrefixTypeName = true
			enums[i] = e1
		}
	}

	return enums, rest, m
}

// isComparableType checks if a Go type can be used as a constant or map key
func isComparableType(schema GoSchema) bool {
	// Arrays, slices, maps, and structs cannot be used as constants or map keys
	if schema.ArrayType != nil {
		return false
	}
	if schema.IsAnyType() {
		return false
	}
	if len(schema.Properties) > 0 {
		return false
	}

	// time.Time cannot be used as a constant (constants must be compile-time values)
	// This handles cases where format: date-time is combined with enum values
	if schema.GoType == "time.Time" {
		return false
	}

	// Only primitive types (string, int, float, bool) can be used as enum constants
	return true
}

// needsQuotesForEnumValue determines if an enum value needs quotes based on the actual value
// rather than just the declared type. This handles cases where the spec declares type: integer
// but provides string enum values.
func needsQuotesForEnumValue(value string, goType string) bool {
	// If the declared type is string, always use quotes
	if goType == "string" {
		return true
	}

	// For integer types, check if the value is actually a valid integer
	if strings.HasPrefix(goType, "int") {
		// Try to parse as an integer - if it fails, it's a string and needs quotes
		_, err := strconv.ParseInt(value, 10, 64)
		return err != nil
	}

	// For float types, check if the value is actually numeric
	if strings.HasPrefix(goType, "float") || goType == "number" {
		// Try to parse as a number - if it fails, it's a string and needs quotes
		_, err := strconv.ParseFloat(value, 64)
		return err != nil
	}

	// For bool type, check if value is actually a boolean
	if goType == "bool" {
		_, err := strconv.ParseBool(value)
		return err != nil
	}

	// Default: no quotes for other types
	return false
}
